<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | KABLAMO]]></title>
  <link href="http://blog.kablamo.org/categories/perl/atom.xml" rel="self"/>
  <link href="http://blog.kablamo.org/"/>
  <updated>2014-04-20T21:06:03-05:00</updated>
  <id>http://blog.kablamo.org/</id>
  <author>
    <name><![CDATA[Eric Johnson]]></name>
    <email><![CDATA[kablamo@kablamo.org]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An experiment - Write code every day]]></title>
    <link href="http://blog.kablamo.org/2014/04/23/write-code-every-day/"/>
    <updated>2014-04-23T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/23/write-code-every-day</id>
    <content type="html"><![CDATA[<p>If you missed John Resig&rsquo;s recent post about <a href="http://ejohn.org/blog/write-code-every-day/">writing code everyday</a> I highly recommend it.</p>

<p>He is a busy guy with a full time job (at Khan Academy), a few open source side
projects (the author of jQuery), a wife, and a few hobbies.  How to sustainably
get stuff done on his open source side projects without his wife leaving him?
He decided to start writing (non work) code for 30 minutes every day.  This by
itself is not a revolutionary idea.  What blew my mind out of my nose and on to
the table are the benefits he encountered:</p>

<ul>
<li><strong>Minimum viable code</strong> &ndash; No time for more than that.</li>
<li><strong>Small but continuous progress</strong> &ndash; No anxiety about not getting stuff done.</li>
<li><strong>Free time on the weekends</strong> &ndash; Instead of working all
weekend to catch up from doing nothing during the week.</li>
<li><strong>Lowered cost of context switching</strong> &ndash; Compared to resuming work on a side project just on the weekends.</li>
<li><strong>Brain solves side project issues in the background</strong></li>
</ul>


<p>Wow, I need to do this too.  So this is
<a href="http://blog.kablamo.org/2014/03/24/experiments/">another</a>
<a href="http://blog.kablamo.org/2014/01/01/no-dessert-forever/">experiment</a> and here
are the rules.</p>

<ol>
<li> I will write code for a minimum of 30 minutes each day.</li>
<li> I must push working code every day.</li>
<li> I will write for a minimum of 10 minutes each day.</li>
<li> I must publish a blog post at least once a week.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codecube.io now supports Perl]]></title>
    <link href="http://blog.kablamo.org/2014/04/19/codecube/"/>
    <updated>2014-04-19T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/19/codecube</id>
    <content type="html"><![CDATA[<p><a href="http://codecube.io">Codecube.io</a> is a jsfiddle type service which runs Perl
code (and other languages) and shows the results in your browser.</p>

<p>The website is written in Go and runs your code inside a Docker container.  It
originally had support for C, Go, Python, and Ruby.  I was looking for an
excuse to play with Docker and Go so I submitted a pull request which added
support for Perl.</p>

<p>See also:</p>

<ul>
<li> The original Codecube <a href="http://hmarr.com/2013/oct/16/codecube-runnable-gists/">blog post</a> which is a good introduction to Docker.</li>
<li> The <a href="https://github.com/hmarr/codecube">Codecube github repo</a>.</li>
<li> My previous post on <a href="http://golang.org/">Go</a>.</li>
<li> My previous post on <a href="http://www.docker.io/">Docker</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - Plack::Builder]]></title>
    <link href="http://blog.kablamo.org/2014/04/12/read-plack-4/"/>
    <updated>2014-04-12T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/12/read-plack-4</id>
    <content type="html"><![CDATA[<ul>
<li><a href="/2014/04/08/read-plack-1">Part 1 &ndash; An Overview</a></li>
<li><a href="/2014/04/09/read-plack-2">Part 2 &ndash; plackup Architecture</a></li>
<li><a href="/2014/04/11/read-plack-3">Part 3 &ndash; PSGI Application Architecture</a></li>
<li><a href="/2014/04/12/read-plack-4"><strong>Part 4 &ndash; Plack::Builder</strong></a></li>
</ul>


<p>Plack::Builder provides a domain specific language (DSL) for middleware
developers.  It looks like this:</p>

<pre><code>use Plack::Builder;

my $app1 = sub { ... };
my $app2 = sub { ... };

builder {
    enable "Deflater";
    enable "Session", store =&gt; "File";
    enable "Debug", panels =&gt; [ qw(DBITrace Memory Timer) ];

    mount "/narwhale" =&gt; $app1;
    mount "/unicorn"  =&gt; $app2;
};
</code></pre>

<p>How does it work?  With three artful tricks.</p>

<h1>Artful trick #1</h1>

<p>The first artful trick is the <code>builder</code> block.</p>

<pre><code>sub builder(&amp;) {
    my $block = shift;
    ...
}
</code></pre>

<p>The <code>&amp;</code> is a function prototype.  Perl offers some limited compile time checking
for parameters passed to subs.  Here is what <code>perldoc perlsub</code> says about <code>&amp;</code>:</p>

<blockquote><p>An &ldquo;&amp;&rdquo; requires an anonymous subroutine, which, if passed as the first
argument, does not require the &ldquo;sub&rdquo; keyword or a subsequent comma.</p></blockquote>

<p>So if I try to pass <code>builder()</code> a scalar or an array or anything thats not an
anonymous subroutine, I will get a compile time error.  But if I pass it an
anonymous subroutine, the compiler will allow things to continue.</p>

<h1>Artful trick #2</h1>

<p>The next artful trick is that Plack::Builder implements the DSL keywords as
subs and then exports those subs.</p>

<pre><code>package Plack::Builder;
use strict;
use parent qw( Exporter );
our @EXPORT = qw( builder enable enable_if mount );
...
sub enable    {...}
sub enable_if {...}
sub mount     {...}
# etc
</code></pre>

<p>Actually thats 90% of the whole thing isn&rsquo;t it?  Now its starting to look
obvious.  But lets continue.</p>

<h1>Artful trick #3</h1>

<p>There is one more interesting idea here.  Notice that if I use <code>enable</code>,
<code>enable_if</code>, or <code>mount</code> outside of a <code>builder</code> block I will get an
error.  This works because the DSL keywords are subs which run code references.
By default those code references refer to code which croaks an error.  But when
<code>builder</code> runs, those references are temporarily replaced with real working
code.</p>

<p>Here&rsquo;s some simplified code to illustrate how it works.</p>

<pre><code>our $_enable = sub { Carp::croak(...) }; # &lt;&lt; default code reference

sub enable { $_enable-&gt;(@_) }

sub builder(&amp;) {
    my $block = shift;
    ...
    local $_enable = sub {...}; # &lt;&lt; temporarily assign real working code
    ...
    my $app = $block-&gt;();
    ...
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - PSGI Application Architecture]]></title>
    <link href="http://blog.kablamo.org/2014/04/11/read-plack-3/"/>
    <updated>2014-04-11T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/11/read-plack-3</id>
    <content type="html"><![CDATA[<ul>
<li><a href="/2014/04/08/read-plack-1">Part 1 &ndash; An Overview</a></li>
<li><a href="/2014/04/09/read-plack-2">Part 2 &ndash; plackup Architecture</a></li>
<li><a href="/2014/04/11/read-plack-3"><strong>Part 3 &ndash; PSGI Application Architecture</strong></a></li>
<li><a href="/2014/04/12/read-plack-4">Part 4 &ndash; Plack::Builder</a></li>
</ul>


<h1>PSGI Applications</h1>

<p>The <a href="https://metacpan.org/pod/distribution/PSGI/PSGI.pod">PSGI spec</a> defines
a PSGI application.</p>

<blockquote><p>A PSGI application is a Perl code reference. It takes exactly one argument,
the environment, and returns an array reference containing exactly three
values.</p></blockquote>

<p>The three values are a status, headers, and a body.  Here is an example:</p>

<pre><code>my $app = sub {
    my $env = shift;
    return [
        '200',
        [ 'Content-Type' =&gt; 'text/plain' ],
        [ "Hello World" ], # or IO::Handle-like object
    ];
};
</code></pre>

<h1>The PSGI environment hash</h1>

<p>The PSGI environment hash is a hashref with many keys.  But mostly it is the
data (headers, body, etc) from an <a href="HTTP::Request">HTTP::Request</a> which has been parsed and put into
a hash for convenient access.</p>

<h1>Middleware</h1>

<p>A middleware component takes a PSGI application and runs it, passing in the
PSGI environment hash.  But before it runs the app, it gets to modify the
environment if it wants to.  And after running the app, it can modify the
response if it wants to.</p>

<h1>Plack::Middleware</h1>

<p>Middleware is a wrapper around a PSGI app.  More than one middleware can be
wrapped around an app, creating a series of layers like an
<a href="http://blogs.perl.org/users/jakob/2012/09/28/middleware-onion.png/500px-MiddlewareOnion.svg.png">onion</a>.
What makes the middleware onion a somewhat unusual construct is the event
driven / callback nature of it.  Lets look at how its implemented.</p>

<p>All middleware inherits from Plack::Middleware which is an itsy bitsy (teeny
weeny) module.  The middleware onion is created with just 2 short subroutines
(notice the <code>call()</code> and <code>prepare_app()</code> subs are written by middleware authors):</p>

<pre><code>sub wrap {
    my($self, $app, @args) = @_;
    if (ref $self) {
        $self-&gt;{app} = $app;
    } else {
        $self = $self-&gt;new({ app =&gt; $app, @args });
    }
    return $self-&gt;to_app;
}

sub to_app {
    my $self = shift;
    $self-&gt;prepare_app;
    return sub { $self-&gt;call(@_) };
}
</code></pre>

<p>How do these subs work together?  The middleware onion is sometimes constructed as follows:</p>

<pre><code>my $app = MyWebApp-&gt;new-&gt;to_app;
$app = Plack::Middleware::A-&gt;wrap($app);
$app = Plack::Middleware::B-&gt;wrap($app);
$app = Plack::Middleware::C-&gt;wrap($app);
</code></pre>

<p>But it might be more clear to write it this way</p>

<pre><code>my $app0 = MyWebApp-&gt;new-&gt;to_app;           # $app0-&gt;($env) runs the web app
$app1 = Plack::Middleware::A-&gt;wrap($app0);  # $app1-&gt;($env) calls P::M::A-&gt;call() which calls $app0-&gt;($env)
$app2 = Plack::Middleware::B-&gt;wrap($app1);  # $app2-&gt;($env) calls P::M::B-&gt;call() which calls $app1-&gt;($env)
$app3 = Plack::Middleware::C-&gt;wrap($app2);  # $app3-&gt;($env) calls P::M::C-&gt;call() which calls $app2-&gt;($env)
                                            # When the server receives a request it calls $app3-&gt;($env)
</code></pre>

<p>So when an event occurs &mdash; for example the PSGI server sees a new request &mdash; it
passes the event to the app.  The app is a chain of callbacks which run each
other.  This is clearly an example of event driven programming.</p>

<h1>Plack::Component and Plack::App</h1>

<p>Plack::Middleware inherits from Plack::Component.  So the most common use of
Plack::Component is in middleware.</p>

<p>Plack::Component can also be used as a tool for creating PSGI applications.  It
has a light dusting of code, but mostly its an interface which is implemented
by modules in the Plack::App namespace.  For example Plack::App::File is a web
app which serves static files from a root directory, and Plack::App::URLMap is
a web app which maps multiple web apps to multiple urls.</p>

<p>But notice that I am not required to use Plack::Component to create a PSGI
application. A PSGI application is just a code reference.  The PSGI spec does
not say that a PSGI application is a reference to code that inherits from
Plack::Component.</p>

<p>The nice thing about using Plack::Component to build my app is that it
provides a common interface for all PSGI apps.  Whenever I see <code>$app</code>, I
can rely on that behavior.  This is clearly important for middleware.  And it
feels good from a design point of view.</p>

<p>But its not required and it adds some complexity.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - plackup Architecture]]></title>
    <link href="http://blog.kablamo.org/2014/04/09/read-plack-2/"/>
    <updated>2014-04-09T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/09/read-plack-2</id>
    <content type="html"><![CDATA[<ul>
<li><a href="/2014/04/08/read-plack-1">Part 1 &ndash; An Overview</a></li>
<li><a href="/2014/04/09/read-plack-2"><strong>Part 2 &ndash; plackup Architecture</strong></a></li>
<li><a href="/2014/04/11/read-plack-3">Part 3 &ndash; PSGI Application Architecture</a></li>
<li><a href="/2014/04/12/read-plack-4">Part 4 &ndash; Plack::Builder</a></li>
</ul>


<h1>Plack::Runner and plackup</h1>

<p><code>plackup</code> starts a PSGI server which executes a PSGI application.  However
the script itself is just a very small wrapper around Plack::Runner which does
all the heavy lifting.  Plack::Runner</p>

<ol>
<li> parses the command line options.</li>
<li> instantiates the chosen loader class (which is in the Plack::Loader namespace).</li>
<li> instatiates the chosen server library (which is in the Plack::Handler namespace).</li>
<li> starts the PSGI server and passes it a PSGI application</li>
</ol>


<h1>Plack::Loader</h1>

<p>Loaders are responsible for instantiating and running the PSGI server.  Here are
the more interesting capabilities a <code>$loader</code> object has:</p>

<ul>
<li><code>$loader-&gt;guess()</code> guesses which server library should be loaded by looking at command line opts, $ENV, and %INC.</li>
<li><code>$loader-&gt;load()</code> instantiates the server library and returns the object.</li>
<li><code>$loader-&gt;run()</code> starts the server.</li>
</ul>


<p>The Plack::Loader namespace contains 3 kinds of loaders:</p>

<ul>
<li>Plack::Loader::Delayed &ndash; delays compilation of the web app until the first request occurs</li>
<li>Plack::Loader::Restarter &ndash; reloads the server if any files are changed</li>
<li>Plack::Loader::Shotgun &ndash; foreach request, forks a child which compiles the web app and runs it</li>
</ul>


<p>I can choose which loader I want using <code>plack --loader</code></p>

<h1>Plack::Handler</h1>

<p>The <a href="https://metacpan.org/pod/distribution/PSGI/PSGI.pod">PSGI spec</a>
tells me that PSGI defines the interface between an application and a server.
Because the PSGI spec is (intentionally) very minimal, there is a good deal of
wiggle room to interpret how an application and a server might want to play
together.</p>

<p>A library in the Plack::Handler namespace is the place where the application
meets the server.  This layer contains all the wiggling.</p>

<p>Lets say I wrote a new server called AngryBrontosaurus and I want to be able to
use it with <code>plackup --server AngryBrontosaurus</code>.  I could implement a small
class like this:</p>

<pre><code>package Plack::Handler::AngryBrontosaurus
use strict;
use AngryBrontosaurus;

sub new {
    my $class = shift;
    bless { @_ }, $class;
}

sub run {
    my ($self, $app) = @_; 
    AngryBrontosaurus-&gt;new-&gt;run($app, $self);
}
</code></pre>

<p>Then, to make sure AngryBrontosaurus and Plack::Handler::AngryBrontosaurus
correctly implement the PSGI spec, I should also test my code with
Plack::Test::Suite.</p>

<pre><code>use Test::More;
use Plack::Test::Suite;
Plack::Test::Suite-&gt;run_server_tests('AngryBrontosaurus');
done_testing;
</code></pre>

<p>Notice that while the Plack::Handler namespace contains classes for several
PSGI servers like Plack::Handler::Starman or Plack::Handler::Twiggy, it also
includes some classes like Plack::Handler::Apache2 and Plack::Handler::FCGI.
Clearly Apache2 was not written with PSGI compliance in mind, but there is glue
in the Plack::Handler::Apache2 layer to enable it to speak with PSGI compliant
applications.</p>

<h1>Sequence diagram</h1>

<p>This diagram describes how Plack::Runner, Plack::Handler, and Plack::Loader
interact.</p>

<p><img src="/images/for-posts/2014-04-01-plack.png"></p>
]]></content>
  </entry>
  
</feed>
