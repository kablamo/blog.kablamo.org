<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | KABLAMO]]></title>
  <link href="http://blog.kablamo.org/categories/perl/atom.xml" rel="self"/>
  <link href="http://blog.kablamo.org/"/>
  <updated>2014-05-27T22:05:32-05:00</updated>
  <id>http://blog.kablamo.org/</id>
  <author>
    <name><![CDATA[Eric Johnson]]></name>
    <email><![CDATA[kablamo@kablamo.org]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HTTP::Request::AsCurl]]></title>
    <link href="http://blog.kablamo.org/2014/05/27/http-request-ascurl/"/>
    <updated>2014-05-27T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/05/27/http-request-ascurl</id>
    <content type="html"><![CDATA[<p>Today, on a whim, I released a module called
<a href="https://metacpan.org/pod/HTTP::Request::AsCurl">HTTP::Request::AsCurl</a> to
CPAN.  It converts an <a href="HTTP::Request">HTTP::Request</a> object to a curl command.</p>

<pre><code>use HTTP::Request::Common;
use HTTP::Request::AsCurl;

my $request = POST('api.earth.defense/weapon1', { 
    target =&gt; 'mothership', 
    when   =&gt; 'now' 
});

say join "\n", $request-&gt;as_curl;
# curl --dump-header - -XPOST "api.earth.defense/weapon1" \
# --data 'target=mothership' \
# --data 'when=now'
</code></pre>

<p>It works by injecting the <code>as_curl()</code> method into the <a href="HTTP::Request">HTTP::Request</a> namespace.
This must be a bad idea and probably not a great bit of code to rely on in a
production environment.  But it is pretty convenient syntax for debugging a
REST API and I couldn&rsquo;t resist.  Thoughts, suggestions, criticism?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - Camel-Snake-Kebab]]></title>
    <link href="http://blog.kablamo.org/2014/05/26/perl-camel-snake-kebab/"/>
    <updated>2014-05-26T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/05/26/perl-camel-snake-kebab</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/qerub/camel-snake-kebab">Camel-Snake-Kebab</a> is a Clojure
library for word case conversions.  I have wanted to see this on CPAN for a
while so last week I finally ported it to Perl.  I even ported the test suite.
Here is a synopsis of my
<a href="https://metacpan.org/pod/String::CamelSnakeKebab">String::CamelSnakeKebab</a> Perl module:</p>

<pre><code>use String::CamelSnakeKebab qw/:all/;

lower_camel_case('flux-capacitor')
       # Returns 'fluxCapacitor'

upper_camel_case('flux-capacitor')
       # Returns 'FluxCapacitor'

lower_snake_case 'ASnakeSlithersSlyly'    
       # Returns 'a_snake_slithers_slyly'

upper_snake_case('ASnakeSlithersSlyly')
       # Returns 'A_Snake_Slithers_Slyly'

constant_case("I am constant")
    # Returns "I_AM_CONSTANT"

kebab_case('Peppers_Meat_Pineapple')
 # Returns 'peppers-meat-pineapple'

http_header_case("x-ssl-cipher")
       # Returns "X-SSL-Cipher"
</code></pre>

<h1>Clojure</h1>

<p>This was my first contact with Clojure and I found the code I was reading to be
bite sized, concise, elegant code.  It reads a bit like math equations to
me.  Or sort of vaguely BNF-like as you will see.  I suspect I would have had a
hard time choosing a better library as my introduction to the language.</p>

<h1>Functional programming</h1>

<p>Clojure is a functional language &mdash; as contrasted with more common imperative
languages.  I will admit I didn&rsquo;t really know what that means.  But hey I
looked it up so I can now present to you 3 central concepts of functional
programming.  (Btw Perl is usually imperative but it can be written
functionally as well.  Although its a little easier and more natural in
Clojure).</p>

<h2>1. First class and higher order functions</h2>

<p>These are functions which accept other functions as arguments.  So functional
programmers enjoy passing around code refs.  Thats not radical for Perl
developers.  Perl has always had excellent support for that.</p>

<p>This flavor of code is often shorter, more general, and less repetitive.
But its harder to read and requires me to use my brains causes me some
discomfort.</p>

<h3>Example</h3>

<p>The most important function in Camel-Snake-Kebab is <code>convert-case</code>.  It is
called by every case conversion function in the library.  It splits a string
into words, applies a case rule to the first word and then a second possibly
different case rule to the remaining words.  Then all the words are joined back
together using the given separator.  Here it is written in Clojure:</p>

<pre><code>(defn convert-case [first-fn rest-fn sep s]
"Converts the case of a string according to the rule for the first
word, remaining words, and the separator."
(let [[first &amp; rest] (split s word-separator-pattern)]
    (join sep (cons (first-fn first) (map rest-fn rest)))))
</code></pre>

<p>Using this I could implement lower snake case like this:</p>

<pre><code>(defn lower-snake-case [s]
    (convert-case lower-case lower-case "_" s))
</code></pre>

<p>Here is the translation in Perl I came up with:</p>

<pre><code>sub convert_case {
    my ($first_coderef, $rest_coderef, $separator, $string) = @_; 

    my ($first, @rest) = split $WORD_SEPARATOR_PATTERN, $string;

    my @words = $first_coderef-&gt;($first);
    push @words, $rest_coderef-&gt;($_) for @rest;

    return join $separator, @words;
}

sub my_lc { lc $_ }

sub lower_snake_case {
    convert_case( \&amp;my_lc, \&amp;my_lc, "_", shift );
}
</code></pre>

<p>The cool thing about this is the different case methods (lower_camel_case,
kebab_case, etc) are not actually implemented this way.  They are dynamically
created when the module loads using a set of conversion rules that looks like
this:</p>

<pre><code>our %CONVERSION_RULES = (
    'lower_camel_case' =&gt; [ \&amp;lc,               \&amp;ucfirst,          ""  ],
    'upper_camel_case' =&gt; [ \&amp;ucfirst,          \&amp;ucfirst,          ""  ],
    'lower_snake_case' =&gt; [ \&amp;lc,               \&amp;lc,               "_" ],
    'upper_snake_case' =&gt; [ \&amp;ucfirst,          \&amp;ucfirst,          "_" ],
    'constant_case'    =&gt; [ \&amp;uc,               \&amp;uc,               "_" ],
    'kebab_case'       =&gt; [ \&amp;lc,               \&amp;lc,               "-" ],
    'http_header_case' =&gt; [ \&amp;http_header_caps, \&amp;http_header_caps, "-" ],
);
</code></pre>

<h2>2. Purely functional functions</h2>

<p>These are functions with no state and no side effects.  In functional
programming I can&rsquo;t do assignments because that alters state (and that is a
side effect).  Which sounds rediculous.  How can I program without doing
assignments?  I&rsquo;m not sure, but the advantage of no side effects is
performance.  I can run functions in parallel without affecting each other.
Also the function&rsquo;s output will depend entirely on the input which makes purely
functional functions great for <a href="https://metacpan.org/pod/Memoize">memoization</a>.</p>

<h3>Example</h3>

<p>This concept was also evident in the code I ported.  Functions did not modify
state.  There were very few if any assignments.  And the output of functions
depended entirely on the input.</p>

<p>I did try memoizing String::CamelSnakeKebab but it did not make it faster.  I&rsquo;m
not sure why.  Perhaps case conversion is just not computationally intensive
enough to make a difference?  So unfortunately I have no example for you.  Any
help in the comments would be awesome.</p>

<h2>3. No <code>for</code> loops</h2>

<p><code>for</code> loops require state and assignments.  To implement loops in functional
programming I&rsquo;m supposed to use recursion.  I didn&rsquo;t see any examples of this
in this library and my brain is grateful to the author for sparing me the
exertion.</p>

<h1>The End</h1>

<p>Thats the end of my story today.  If you are interested, compare the
<a href="https://github.com/kablamo/perl-string-camelsnakekebab/blob/master/lib/String/CamelSnakeKebab.pm">Perl source code</a>
with the
<a href="https://github.com/qerub/camel-snake-kebab/blob/stable/src/camel_snake_kebab.clj">Clojure source code</a>.
Each version is about 70 lines of code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test::Pretty - because TAP is unnattractive]]></title>
    <link href="http://blog.kablamo.org/2014/05/08/test-pretty/"/>
    <updated>2014-05-08T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/05/08/test-pretty</id>
    <content type="html"><![CDATA[<p><a href="https://metacpan.org/pod/Test::Pretty">Test::Pretty</a> makes my tests look like this:</p>

<p><img src="/images/for-posts/2014-05-08-test-pretty.png" width="500"></p>

<p>This is especially nice when I have subtests.</p>

<p><img src="/images/for-posts/2014-05-08-test-pretty-subtest2.png" width="200">
<img src="/images/for-posts/2014-05-08-test-pretty-subtest.png" width="200"></p>

<h1>How it works</h1>

<p>I can enable Test::Pretty like this</p>

<pre><code>prove -MTest::Pretty -vlr t
</code></pre>

<p>But typing extra characters is not fun.  Happily
<a href="http://tokuhirom.github.io/">@tokuhirom</a> also created a prove
<a href="https://metacpan.org/pod/App::Prove::Plugin::retty">plugin</a> (which is included
with the Test::Pretty module) which allows me to do this:</p>

<pre><code>prove -Pretty -vlr t
</code></pre>

<p>Shorter but still too much typing so I created a <code>~/.proverc</code> file which contains
the following lines:</p>

<pre><code>--lib
--verbose
--comments
--recurse
-Pretty
</code></pre>

<p>Now I can get pretty verbose recursive (etc) tests and I only need to type this</p>

<pre><code>prove t
</code></pre>

<p>You can view my <code>~/.proverc</code> and more goodies in my <a href="https://github.com/kablamo/dotfiles">dotfiles repo</a>).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why reading code is good for me]]></title>
    <link href="http://blog.kablamo.org/2014/04/23/reading-code/"/>
    <updated>2014-04-23T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/23/reading-code</id>
    <content type="html"><![CDATA[<ul>
<li><strong>So I can start kicking butt faster</strong> &ndash; When I start a new job or a new
contract. Or when I hack on a new feature.  Or every day of my life as a
programmer that involves legacy code.  Yeah pretty much all the time.</li>
<li><strong>So I can learn new tricks</strong> &ndash; Healthy languages evolve.  Idioms and slang
are tools for more efficiently expressing ideas.  I want to be on top of
that.  Also its best way to peak inside the mind of a talented developer and
steal and copy their skills.</li>
<li><strong>So I can work better with others</strong> &ndash; I understand their idioms because I have
seen them before.  And I can probably articulate why their idioms are awesome
or feeble.</li>
</ul>


<p>I must remember that attitude matters.  If I think of reading code as a painful
chore it will be.  But if I look for opportunity I find it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An experiment - Write code every day]]></title>
    <link href="http://blog.kablamo.org/2014/04/20/write-code-every-day/"/>
    <updated>2014-04-20T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/20/write-code-every-day</id>
    <content type="html"><![CDATA[<p>If you missed John Resig&rsquo;s recent post about <a href="http://ejohn.org/blog/write-code-every-day/">writing code everyday</a> I highly recommend it.</p>

<p>He is a busy guy with a full time job (at Khan Academy), a few open source side
projects (the author of jQuery), a wife, and a few hobbies.  How to sustainably
get stuff done on his open source side projects without his wife leaving him?
He decided to start writing (non work) code for 30 minutes every day.  This by
itself is not a revolutionary idea.  What blew my mind out of my nose and on to
the table are the benefits he encountered:</p>

<ul>
<li><strong>Minimum viable code</strong> &ndash; No time for more than that.</li>
<li><strong>Small but continuous progress</strong> &ndash; No anxiety about not getting stuff done.</li>
<li><strong>Free time on the weekends</strong> &ndash; Instead of working all
weekend to catch up from doing nothing during the week.</li>
<li><strong>Lowered cost of context switching</strong> &ndash; Compared to resuming work on a side project just on the weekends.</li>
<li><strong>Brain solves side project issues in the background</strong></li>
</ul>


<p>Wow, I need to do this too.  So this is
<a href="http://blog.kablamo.org/2014/03/24/experiments/">another</a>
<a href="http://blog.kablamo.org/2014/01/01/no-dessert-forever/">experiment</a> and here
are the rules.</p>

<ol>
<li> I will write code for a minimum of 30 minutes each day.</li>
<li> I must push working code every day.</li>
<li> I will write for a minimum of 10 minutes each day.</li>
<li> I must publish a blog post at least once a week.</li>
</ol>

]]></content>
  </entry>
  
</feed>
