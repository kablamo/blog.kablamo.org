<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | KABLAMO]]></title>
  <link href="http://blog.kablamo.org/categories/perl/atom.xml" rel="self"/>
  <link href="http://blog.kablamo.org/"/>
  <updated>2014-04-11T08:27:31-04:00</updated>
  <id>http://blog.kablamo.org/</id>
  <author>
    <name><![CDATA[Eric Johnson]]></name>
    <email><![CDATA[kablamo@kablamo.org]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reading code - PSGI Application Architecture]]></title>
    <link href="http://blog.kablamo.org/2014/04/11/read-plack-3/"/>
    <updated>2014-04-11T00:00:00-04:00</updated>
    <id>http://blog.kablamo.org/2014/04/11/read-plack-3</id>
    <content type="html"><![CDATA[<ul>
<li><a href="/2014/04/08/read-plack-1">Part 1 &ndash; An Overview</a></li>
<li><a href="/2014/04/09/read-plack-2">Part 2 &ndash; plackup Architecture</a></li>
<li><a href="/2014/04/11/read-plack-3"><strong>Part 3 &ndash; PSGI Application Architecture</strong></a></li>
<li><a href="/2014/04/12/read-plack-4">Part 4 &ndash; Plack::Builder</a></li>
</ul>


<h1>PSGI Applications</h1>

<p>The <a href="https://metacpan.org/pod/distribution/PSGI/PSGI.pod">PSGI spec</a> defines
a PSGI application.</p>

<blockquote><p>A PSGI application is a Perl code reference. It takes exactly one argument,
the environment, and returns an array reference containing exactly three
values [(a status, header, and body)].</p></blockquote>

<p>Here is an example:</p>

<pre><code>my $app = sub {
    my $env = shift;
    return [
        '200',
        [ 'Content-Type' =&gt; 'text/plain' ],
        [ "Hello World" ], # or IO::Handle-like object
    ];
};
</code></pre>

<h1>The PSGI environment hash</h1>

<p>The PSGI environment hash is a hashref with many keys.  But mostly it is the
data (headers, body, etc) from a <a href="HTTP::Request">HTTP::Request</a> which have been parsed put into
a hash for convenient access.</p>

<h1>Middleware</h1>

<p>A middleware component takes a PSGI application and runs it, passing in the
PSGI environment hash.  But before it runs the app, it gets to modify the
environment if it wants to.  And after running the app, it can modify the
response if it wants to.</p>

<h1>Plack::Middleware</h1>

<p>Middleware is a wrapper around a PSGI app.  More than one middleware can be
wrapped around an app, creating a series of layers like an
<a href="http://blogs.perl.org/users/jakob/2012/09/28/middleware-onion.png/500px-MiddlewareOnion.svg.png">onion</a>.
What makes the middleware onion a somewhat unusual construct is the event
driven / callback nature of it.  Lets look at how its implemented.</p>

<p>All middleware inherits from Plack::Middleware which is an itsy bitsy (teeny
weeny) module.  The middleware onion is created with just 2 short subroutines
(notice the <code>call()</code> and <code>prepare_app()</code> subs are written by middleware authors):</p>

<pre><code>sub wrap {
    my($self, $app, @args) = @_;
    if (ref $self) {
        $self-&gt;{app} = $app;
    } else {
        $self = $self-&gt;new({ app =&gt; $app, @args });
    }
    return $self-&gt;to_app;
}

sub to_app {
    my $self = shift;
    $self-&gt;prepare_app;
    return sub { $self-&gt;call(@_) };
}
</code></pre>

<p>How do these subs work together?  The middleware onion is sometimes constructed as follows:</p>

<pre><code>my $app = MyWebApp-&gt;new-&gt;to_app;
$app = Plack::Middleware::A-&gt;wrap($app);
$app = Plack::Middleware::B-&gt;wrap($app);
$app = Plack::Middleware::C-&gt;wrap($app);
</code></pre>

<p>But it might be more clear to write it this way</p>

<pre><code>my $app0 = MyWebApp-&gt;new-&gt;to_app;           # $app0-&gt;($env) runs the web app
$app1 = Plack::Middleware::A-&gt;wrap($app0);  # $app1-&gt;($env) calls P::M::A-&gt;call() which calls $app0-&gt;($env)
$app2 = Plack::Middleware::B-&gt;wrap($app1);  # $app2-&gt;($env) calls P::M::B-&gt;call() which calls $app1-&gt;($env)
$app3 = Plack::Middleware::C-&gt;wrap($app2);  # $app3-&gt;($env) calls P::M::C-&gt;call() which calls $app2-&gt;($env)
                                            # When the server receives a request it calls $app3-&gt;($env)
</code></pre>

<p>So when an event occurs &mdash; for example the PSGI server sees a new request &mdash; it
passes the event to the app.  The app is a chain of callbacks which run each
other.  This is clearly an example of event driven programming.</p>

<h1>Plack::Component and Plack::App</h1>

<p>Plack::Middleware inherits from Plack::Component.  So the most common use of
Plack::Component is in middleware.</p>

<p>Plack::Component can also be used as a tool for creating PSGI applications.  It
has a light dusting of code, but mostly its an interface which is implemented
by modules in the Plack::App namespace.  For example Plack::App::File is a web
app which serves static files from a root directory, and Plack::App::URLMap is
a web app which maps multiple web apps to multiple urls.</p>

<p>But notice that I am not required to use Plack::Component to create a PSGI
application. A PSGI application is just a code reference.  The PSGI spec does
not say that a PSGI application is a reference to code that inherits from
Plack::Component.</p>

<p>The nice thing about using Plack::Component to build my app is that it
provides a common interface for all PSGI apps.  Whenever I see <code>$app</code>, I
can rely on that behavior.  This is clearly important for middleware.  And it
feels good from a design point of view.</p>

<p>But its not required and it adds some complexity.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - plackup Architecture]]></title>
    <link href="http://blog.kablamo.org/2014/04/09/read-plack-2/"/>
    <updated>2014-04-09T00:00:00-04:00</updated>
    <id>http://blog.kablamo.org/2014/04/09/read-plack-2</id>
    <content type="html"><![CDATA[<ul>
<li><a href="/2014/04/08/read-plack-1">Part 1 &ndash; An Overview</a></li>
<li><a href="/2014/04/09/read-plack-2"><strong>Part 2 &ndash; plackup Architecture</strong></a></li>
<li><a href="/2014/04/11/read-plack-3">Part 3 &ndash; PSGI Application Architecture</a></li>
<li><a href="/2014/04/12/read-plack-4">Part 4 &ndash; Plack::Builder</a></li>
</ul>


<h1>Plack::Runner and plackup</h1>

<p><code>plackup</code> starts a PSGI server which executes a PSGI application.  However
the script itself is just a very small wrapper around Plack::Runner which does
all the heavy lifting.  Plack::Runner</p>

<ol>
<li> parses the command line options.</li>
<li> instantiates the chosen loader class (which is in the Plack::Loader namespace).</li>
<li> instatiates the chosen server library (which is in the Plack::Handler namespace).</li>
<li> starts the PSGI server and passes it a PSGI application</li>
</ol>


<h1>Plack::Loader</h1>

<p>Loaders are responsible for instantiating and running the PSGI server.  Here are
the more interesting capabilities a <code>$loader</code> object has:</p>

<ul>
<li><code>$loader-&gt;guess()</code> guesses which server library should be loaded by looking at command line opts, $ENV, and %INC.</li>
<li><code>$loader-&gt;load()</code> instantiates the server library and returns the object.</li>
<li><code>$loader-&gt;run()</code> starts the server.</li>
</ul>


<p>The Plack::Loader namespace contains 3 kinds of loaders:</p>

<ul>
<li>Plack::Loader::Delayed &ndash; delays compilation of the web app until the first request occurs</li>
<li>Plack::Loader::Restarter &ndash; reloads the server if any files are changed</li>
<li>Plack::Loader::Shotgun &ndash; foreach request, forks a child which compiles the web app and runs it</li>
</ul>


<p>I can choose which loader I want using <code>plack --loader</code></p>

<h1>Plack::Handler</h1>

<p>The <a href="https://metacpan.org/pod/distribution/PSGI/PSGI.pod">PSGI spec</a>
tells me that PSGI defines the interface between an application and a server.
Because the PSGI spec is (intentionally) very minimal, there is a good deal of
wiggle room to interpret how an application and a server might want to play
together.</p>

<p>A library in the Plack::Handler namespace is the place where the application
meets the server.  This layer contains all the wiggling.</p>

<p>Lets say I wrote a new server called AngryBrontosaurus and I want to be able to
use it with <code>plackup --server AngryBrontosaurus</code>.  I could implement a small
class like this:</p>

<pre><code>package Plack::Handler::AngryBrontosaurus
use strict;
use AngryBrontosaurus;

sub new {
    my $class = shift;
    bless { @_ }, $class;
}

sub run {
    my ($self, $app) = @_; 
    AngryBrontosaurus-&gt;new-&gt;run($app, $self);
}
</code></pre>

<p>Then, to make sure AngryBrontosaurus and Plack::Handler::AngryBrontosaurus
correctly implement the PSGI spec, I should also test my code with
Plack::Test::Suite.</p>

<pre><code>use Test::More;
use Plack::Test::Suite;
Plack::Test::Suite-&gt;run_server_tests('AngryBrontosaurus');
done_testing;
</code></pre>

<p>Notice that while the Plack::Handler namespace contains classes for several
PSGI servers like Plack::Handler::Starman or Plack::Handler::Twiggy, it also
includes some classes like Plack::Handler::Apache2 and Plack::Handler::FCGI.
Clearly Apache2 was not written with PSGI compliance in mind, but there is glue
in the Plack::Handler::Apache2 layer to enable it to speak with PSGI compliant
applications.</p>

<h1>Sequence diagram</h1>

<p>This diagram describes how Plack::Runner, Plack::Handler, and Plack::Loader
interact.</p>

<p><img src="/images/for-posts/2014-04-01-plack.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - Plack]]></title>
    <link href="http://blog.kablamo.org/2014/04/08/read-plack-1/"/>
    <updated>2014-04-08T00:00:00-04:00</updated>
    <id>http://blog.kablamo.org/2014/04/08/read-plack-1</id>
    <content type="html"><![CDATA[<p>I write lots of code.  But I want to be better and faster at reading code.
When I had the privilege of working with @ranguard I discovered he is a code
reading <em>cheetah</em> and I always envied that.  So I&rsquo;ve decided to practice
by reading the source code of various CPAN modules.  I&rsquo;m starting with Plack.</p>

<ul>
<li><a href="/2014/04/08/read-plack-1"><strong>Part 1 &ndash; An Overview</strong></a></li>
<li><a href="/2014/04/09/read-plack-2">Part 2 &ndash; plackup Architecture</a></li>
<li><a href="/2014/04/11/read-plack-3">Part 3 &ndash; PSGI Application Architecture</a></li>
<li><a href="/2014/04/12/read-plack-4">Part 4 &ndash; Plack::Builder</a></li>
</ul>


<h1>Plack</h1>

<p>Plack describes itself as a set of tools for using
<a href="https://metacpan.org/pod/PSGI">PSGI</a> (the Perl Server Gateway Interface).</p>

<p>The earliest release of Plack on CPAN is version 0.9000 from 2009-10-13.  There
were releases several times a week for the first <strong>two years</strong>.  Impressively, in
2012 releases were still happening roughly once a week.  In 2013 things seem to
have cooled and now releases happen about once a month.</p>

<p>The code itself is written tersely and with attention to detail.  There are
almost no comments.  In fact 43 out of 71 files have fewer than 3 comments.
Of course the code is very well written which makes comments less necessary and
nowadays there is quite a bit of excellent POD as well.</p>

<p>The code also makes heavy use of callbacks (code references).  That is to say
its heavily event driven. Which makes sense given the event driven nature of web
servers.  For me this gave the code a JavaScript flavor.  Take for example
<code>Plack::Util::foreach</code> which works just like
<a href="http://api.jquery.com/jQuery.each/">jQuery.each()</a> by iterating over an array
calling a code reference on each item.</p>

<pre><code>Plack::Util::foreach([1,2,3], sub { print shift }); # prints "123"
</code></pre>

<h2>Background reading</h2>

<p>The most important thing to read is the <a href="https://metacpan.org/pod/distribution/PSGI/PSGI.pod">PSGI spec</a>.
This is the problem Plack was built to solve.  Its clear and well
written but perhaps also a little boring and lacking in context. Still I found
it very helpful to refer back to while reading the code.</p>

<h2>Getting started</h2>

<pre><code>~/code ⚡ git clone git@github.com:plack/Plack.git
~/code ⚡ cd Plack
</code></pre>

<p>The first thing I noticed is a <code>cpanfile</code> containing a list of the project
dependencies.  Because understanding and running the tests is often useful
when reading new code I installed the dependencies using
<a href="https://metacpan.org/pod/Carton">Carton</a> and ran the tests.</p>

<pre><code>~/code/Plack ⚡ carton
~/code/Plack ⚡ prove -rl t
</code></pre>

<h2>Who works on Plack?</h2>

<p>Lets get a feel for who is involved in the project.</p>

<pre><code>~/code/Plack ⚡ git shortlog --summary --numbered | head
  1567  Tatsuhiko Miyagawa
    70  Kazuho Oku
    68  Tokuhiro Matsuno
    20  Daisuke Murase
    20  Jesse Luehrs
    19  yappo
    16  Karen Etheridge
    16  Mark Stosberg
    12  hiratara
    11  Stevan Little
</code></pre>

<h2>How big is it?</h2>

<pre><code>~/code/Plack ⚡ tree lib | tail -1
17 directories, 70 files

~/code/Plack ⚡ cloc . 2&gt;/dev/null | tail -13
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Perl                            82           2889           3341           5309
Bourne Shell                     8             55            138            251
YAML                             1              0              0             19
HTML                             3              2              0             14
Python                           1              2              1              6
Javascript                       1              0              0              1
CSS                              1              0              0              1
-------------------------------------------------------------------------------
SUM:                            97           2948           3480           5601
-------------------------------------------------------------------------------
</code></pre>

<h2>What is the lib directory structure like?</h2>

<p>Unfortunately with 71 files in the lib directory its hard to grok whats
happening in a single glance so maybe thats not a great question.  Instead I
found it helpful to group the code by functionality.  I came up
with 3 major categories which look like this:</p>

<ul>
<li><em>Category 1</em> &ndash; Modules for loading and running PSGI servers

<ul>
<li>plackup</li>
<li>Plack::Handler</li>
<li>Plack::Handler::*</li>
<li>Plack::Loader</li>
<li>Plack::Loader::*</li>
<li>Plack::Runner</li>
</ul>
</li>
<li><em>Category 2</em> &ndash; Modules for building PSGI apps

<ul>
<li>Plack::App::*</li>
<li>Plack::Builder</li>
<li>Plack::Component</li>
<li>Plack::Middleware</li>
<li>Plack::Middleware::*</li>
</ul>
</li>
<li><em>Category 3</em> &ndash; Modules for testing

<ul>
<li>Plack::Test</li>
<li>Plack::Test::*</li>
<li>Plack::<a href="HTTP::Message::PSGI">HTTP::Message::PSGI</a></li>
<li>Plack::LWPish</li>
</ul>
</li>
</ul>


<p>However I also got crazy and went ahead and listed <em>everything</em> in the lib
directory along with a brief description.  I guess it might be handy for
reference purposes.  The numbers (1), (2), (3) below correspond to the three
categories I listed above.</p>

<pre><code>~/code/Plack ⚡ tree lib
lib
├── HTTP
│   ├── Message
│   │   └── PSGI.pm               # (3) Converts an HTTP::Request to a PSGI env hash
│   └── Server                    
│       └── PSGI.pm               # (1) Reference PSGI web server; no deps; not usually for prod
├── Plack                         
│   ├── App                       # (2) These libs inherit from Plack::Component; they are PSGI web apps
│   │   ├── Cascade.pm               # Foreach request, tries a number of PSGI apps until one is successful
│   │   ├── CGIBin.pm                # Creates many PSGI apps for a directory with many CGI scripts (uses WrapCGI.pm)
│   │   ├── Directory.pm             # Serves a directory of files
│   │   ├── File.pm                  # Serves a file
│   │   ├── PSGIBin.pm               # Create PSGI apps from a directory of .psgi files
│   │   ├── URLMap.pm                # Maps a url to a PSGI app
│   │   └── WrapCGI.pm               # Creates a single PSGI app from a single CGI script
│   ├── Builder.pm                # (2) A DSL for building Plack Middleware
│   ├── Component.pm              # (2) A (optional) tool for building PSGI web apps
│   ├── Handler
│   │   ├── Apache1.pm
│   │   ├── Apache2
│   │   │   └── Registry.pm
│   │   ├── Apache2.pm
│   │   ├── CGI.pm
│   │   ├── FCGI.pm
│   │   ├── HTTP
│   │   │   └── Server
│   │   │       └── PSGI.pm                 # A Plack::Handler for HTTP::Server::PSGI
│   │   └── Standalone.pm            # Alias for Plack::Handler::HTTP::Server::PSGI
│   ├── Handler.pm                # (1) Instantiate and run PSGI compatible servers
│   ├── HTTPParser
│   │   └── PP.pm                    # Parse HTTP headers with XS
│   ├── HTTPParser.pm             # (1) Parse HTTP headers; used by HTTP::Server::PSGI
│   ├── Loader
│   │   ├── Delayed.pm               # Delay compilation of the PSGI app until the first request
│   │   ├── Restarter.pm             # Restart the server when a watched file changes
│   │   └── Shotgun.pm               # Recompile the PSGI app for every request
│   ├── Loader.pm                 # (1) Load PSGI compatible web servers
│   ├── LWPish.pm                 # (3) Light version of LWP for testing
│   ├── Middleware                
│   │   ├── AccessLog
│   │   │   └── Timed.pm                # Write access logs but can handle a fake File::IO body
│   │   ├── AccessLog.pm             # Write access logs
│   │   ├── Auth
│   │   │   └── Basic.pm                # Basic authentication
│   │   ├── BufferedStreaming.pm     # Enable streaming for servers that don't
│   │   ├── Chunked.pm               # Implements part of HTTP/1.1 - chunked HTTP transfer encoding
│   │   ├── ConditionalGET.pm        # Implements part of HTTP/1.1 - Conditional GET
│   │   ├── Conditional.pm           # Runs the specified middleware if a specified condition is met
│   │   ├── ContentLength.pm         # Adds a Content-Length header if possible
│   │   ├── ContentMD5.pm            # Sets the Content-MD5 header when the body is an arrayref
│   │   ├── ErrorDocument.pm         # Show different error documents for different HTTP errors
│   │   ├── Head.pm                  # Delete any response body from HEAD requests
│   │   ├── HTTPExceptions.pm        # Redirect to an error page when HTTP::Exceptions are caught
│   │   ├── IIS6ScriptNameFix.pm     # Fix for IIS
│   │   ├── IIS7KeepAliveFix.pm      # Fix for IIS
│   │   ├── JSONP.pm                 # Change JSON responses to JSONP if a callback param is specified
│   │   ├── LighttpdScriptNameFix.pm # Fix for Lighttpd
│   │   ├── Lint.pm                  # Checks input/output for compliance w/PSGI spec
│   │   ├── Log4perl.pm              # Log with Log::Log4Perl
│   │   ├── LogDispatch.pm           # Log with Log::Dispatch
│   │   ├── NullLogger.pm            # Don't log anything
│   │   ├── RearrangeHeaders.pm      # Fix for very old MSIE and broken HTTP proxy servers
│   │   ├── Recursive.pm             # Allows the app to forward the request to a different (url) path
│   │   ├── Refresh.pm               # Similar to Plack::Loader::Restarter but less effective
│   │   ├── Runtime.pm               # Sets the 'X-Runtime' HTTP response header = app's response time
│   │   ├── SimpleContentFilter.pm   # Filter response content
│   │   ├── SimpleLogger.pm          # Logs messages
│   │   ├── StackTrace.pm            # Displays a stacktrace when a PSGI app dies
│   │   ├── Static.pm                # Serve static files
│   │   ├── XFramework.pm            # Adds an X-Framework HTTP response header
│   │   └── XSendfile.pm             # Adds an X-Sendfile HTTP response header
│   ├── Middleware.pm             # (2) Wraps PSGI apps; can modify incoming requests / outgoing responses
│   ├── MIME.pm                   # A list of MIME types (mostly)
│   ├── Request
│   │   └── Upload.pm                # A subclass of Plack::Request for file uploads
│   ├── Request.pm                # (2) Low level request obj for middleware and web apps
│   ├── Response.pm               # (2) Low level response obj for middleware and web apps
│   ├── Runner.pm                 # (1) The guts of plackup -- uses Plack::Loader and Plack::Handler
│   ├── TempBuffer.pm             # For backward compat. Saves data in memory or to a file if its big;
│   ├── Test
│   │   ├── MockHTTP.pm              # Test a PSGI app without using a server (faster)
│   │   ├── Server.pm                # Test a PSGI app using a very small server (fast)
│   │   └── Suite.pm                 # Ensure the web server complies with the PSGI spec
│   ├── Test.pm                   # (3) A factory for generating test objects
│   ├── Util
│   │   └── Accessor.pm              # Light version of Class::Accessor for backward compat
│   └── Util.pm                   # Misc but important utilities used throughout the code base
└── Plack.pm                   # No code here -- just pod and a version number
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Look around assertions in Perl regular expressions]]></title>
    <link href="http://blog.kablamo.org/2014/03/31/regex/"/>
    <updated>2014-03-31T00:00:00-04:00</updated>
    <id>http://blog.kablamo.org/2014/03/31/regex</id>
    <content type="html"><![CDATA[<p>When Perl&rsquo;s regex engine evaluates a string, it moves from left to right, one
letter at a time checking the match at each position.  That position is called
the <em>current match position</em>.</p>

<p>Look around assertions allow you to match a specific pattern before or after
the current match position without moving the match position.</p>

<h1>Look ahead assertions</h1>

<p>Look ahead assertions match the text after the current match position
(without moving the match position).  They look like <code>(?=pattern)</code>.</p>

<pre><code>my $job = "space cowboy";
$job =~ /space (?=cow)/;    # matches
$job =~ /space (?=cow)cow/; # also matches
</code></pre>

<h1>Look behind assertions</h1>

<p>Look behind assertions match the text before the current match position
(without moving the match position).  They look like <code>(?&lt;=pattern)</code>.</p>

<pre><code>my $job = "space cowboy";
$job =~ /(?&lt;=space) cowboy/;      # matches
$job =~ /space(?&lt;=space) cowboy/; # also matches
</code></pre>

<h1>Positive and negative look ahead assertions</h1>

<p><em>Positive</em> look ahead assertions are look ahead assertions which match when their
subpattern matches. They look like <code>(?=pattern)</code>.</p>

<pre><code> my $job = "space cowboy";
 $job =~ /space (?=cowboy)/;   # matches
</code></pre>

<p><em>Negative</em> look ahead assertions are look ahead assertions which match when their
subpattern fails. They look like <code>(?!pattern)</code>.</p>

<pre><code> my $job = "space cowboy";
 $job =~ /space (?!mooseboy)/;   # matches
</code></pre>

<h1>Positive and negative look behind assertions</h1>

<p>Positive look behind assertions are look behind assertions which match when their
subpattern matches. They look like <code>(?&lt;=pattern)</code>.</p>

<pre><code> my $job = "space cowboy";
 $job =~ /(?&lt;=space) cowboy/;   # matches
</code></pre>

<p>Negative look behind assertions are look behind assertions which match when
their subpattern fails. They look like <code>(?&lt;!pattern)</code>.</p>

<pre><code> my $job = "space cowboy";
 $job =~ /(?&lt;!earth) cowboy/;   # matches
</code></pre>

<p>For more details see <code>perldoc perlre</code>.  I also recommend the DuckDuckGo
<a href="https://duckduckgo.com/?q=regex+cheat+sheet">regex cheat sheet</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim cheat sheet]]></title>
    <link href="http://blog.kablamo.org/2014/03/28/ddg-vim/"/>
    <updated>2014-03-28T00:00:00-04:00</updated>
    <id>http://blog.kablamo.org/2014/03/28/ddg-vim</id>
    <content type="html"><![CDATA[<p>I created a Vim cheat sheet instant answer for DuckDuckDuckGo.  If you search
for <a href="https://duckduckgo.com/?q=vim+cheat+sheet">vim cheat sheet</a> or
<a href="https://duckduckgo.com/?q=vim+help">vim help</a> you will get a result like this:</p>

<p><img src="/images/for-posts/2014-03-28-ddg-vim.png" width="700" height="424"></p>

<p>The data is from rtorruellas&rsquo;s excellent <a href="http://rtorruellas.com/vim-cheat-sheet/">vim cheat sheet</a>
(also available on <a href="https://github.com/rtorr/vim-cheat-sheet">github</a>) which has a responsive
mobile friendly layout and is also available in Japanese.</p>
]]></content>
  </entry>
  
</feed>
