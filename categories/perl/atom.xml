<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | KABLAMO]]></title>
  <link href="http://blog.kablamo.org/categories/perl/atom.xml" rel="self"/>
  <link href="http://blog.kablamo.org/"/>
  <updated>2014-05-05T22:24:58-05:00</updated>
  <id>http://blog.kablamo.org/</id>
  <author>
    <name><![CDATA[Eric Johnson]]></name>
    <email><![CDATA[kablamo@kablamo.org]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why reading code is good for me]]></title>
    <link href="http://blog.kablamo.org/2014/04/23/reading-code/"/>
    <updated>2014-04-23T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/23/reading-code</id>
    <content type="html"><![CDATA[<ul>
<li><strong>So I can start kicking butt faster</strong> &ndash; When I start a new job or a new
contract. Or when I hack on a new feature.  Or every day of my life as a
programmer that involves legacy code.  Yeah pretty much all the time.</li>
<li><strong>So I can learn new tricks</strong> &ndash; Healthy languages evolve.  Idioms and slang
are tools for more efficiently expressing ideas.  I want to be on top of
that.  Also its best way to peak inside the mind of a talented developer and
steal and copy their skills.</li>
<li><strong>So I can work better with others</strong> &ndash; I understand their idioms because I have
seen them before.  And I can probably articulate why their idioms are awesome
or feeble.</li>
</ul>


<p>I must remember that attitude matters.  If I think of reading code as a painful
chore it will be.  But if I look for opportunity I find it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An experiment - Write code every day]]></title>
    <link href="http://blog.kablamo.org/2014/04/20/write-code-every-day/"/>
    <updated>2014-04-20T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/20/write-code-every-day</id>
    <content type="html"><![CDATA[<p>If you missed John Resig&rsquo;s recent post about <a href="http://ejohn.org/blog/write-code-every-day/">writing code everyday</a> I highly recommend it.</p>

<p>He is a busy guy with a full time job (at Khan Academy), a few open source side
projects (the author of jQuery), a wife, and a few hobbies.  How to sustainably
get stuff done on his open source side projects without his wife leaving him?
He decided to start writing (non work) code for 30 minutes every day.  This by
itself is not a revolutionary idea.  What blew my mind out of my nose and on to
the table are the benefits he encountered:</p>

<ul>
<li><strong>Minimum viable code</strong> &ndash; No time for more than that.</li>
<li><strong>Small but continuous progress</strong> &ndash; No anxiety about not getting stuff done.</li>
<li><strong>Free time on the weekends</strong> &ndash; Instead of working all
weekend to catch up from doing nothing during the week.</li>
<li><strong>Lowered cost of context switching</strong> &ndash; Compared to resuming work on a side project just on the weekends.</li>
<li><strong>Brain solves side project issues in the background</strong></li>
</ul>


<p>Wow, I need to do this too.  So this is
<a href="http://blog.kablamo.org/2014/03/24/experiments/">another</a>
<a href="http://blog.kablamo.org/2014/01/01/no-dessert-forever/">experiment</a> and here
are the rules.</p>

<ol>
<li> I will write code for a minimum of 30 minutes each day.</li>
<li> I must push working code every day.</li>
<li> I will write for a minimum of 10 minutes each day.</li>
<li> I must publish a blog post at least once a week.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codecube.io now supports Perl]]></title>
    <link href="http://blog.kablamo.org/2014/04/19/codecube/"/>
    <updated>2014-04-19T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/19/codecube</id>
    <content type="html"><![CDATA[<p><a href="http://codecube.io">Codecube.io</a> is a jsfiddle type service which runs Perl
code (and other languages) and shows the results in your browser.</p>

<p>The website is written in Go and runs your code inside a Docker container.  It
originally had support for C, Go, Python, and Ruby.  I was looking for an
excuse to play with Docker and Go so I submitted a pull request which added
support for Perl.</p>

<p>See also:</p>

<ul>
<li> The original Codecube <a href="http://hmarr.com/2013/oct/16/codecube-runnable-gists/">blog post</a> which is a good introduction to Docker.</li>
<li> The <a href="https://github.com/hmarr/codecube">Codecube github repo</a>.</li>
<li> My previous post on <a href="http://golang.org/">Go</a>.</li>
<li> My previous post on <a href="http://www.docker.io/">Docker</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - Plack::Builder]]></title>
    <link href="http://blog.kablamo.org/2014/04/12/read-plack-4/"/>
    <updated>2014-04-12T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/12/read-plack-4</id>
    <content type="html"><![CDATA[<ul>
<li><a href="/2014/04/08/read-plack-1">Part 1 &ndash; An Overview</a></li>
<li><a href="/2014/04/09/read-plack-2">Part 2 &ndash; plackup Architecture</a></li>
<li><a href="/2014/04/11/read-plack-3">Part 3 &ndash; PSGI Application Architecture</a></li>
<li><a href="/2014/04/12/read-plack-4"><strong>Part 4 &ndash; Plack::Builder</strong></a></li>
</ul>


<p>Plack::Builder provides a domain specific language (DSL) for middleware
developers.  It looks like this:</p>

<pre><code>use Plack::Builder;

my $app1 = sub { ... };
my $app2 = sub { ... };

builder {
    enable "Deflater";
    enable "Session", store =&gt; "File";
    enable "Debug", panels =&gt; [ qw(DBITrace Memory Timer) ];

    mount "/narwhale" =&gt; $app1;
    mount "/unicorn"  =&gt; $app2;
};
</code></pre>

<p>How does it work?  With three artful tricks.</p>

<h1>Artful trick #1</h1>

<p>The first artful trick is the <code>builder</code> block.</p>

<pre><code>sub builder(&amp;) {
    my $block = shift;
    ...
}
</code></pre>

<p>The <code>&amp;</code> is a function prototype.  Perl offers some limited compile time checking
for parameters passed to subs.  Here is what <code>perldoc perlsub</code> says about <code>&amp;</code>:</p>

<blockquote><p>An &ldquo;&amp;&rdquo; requires an anonymous subroutine, which, if passed as the first
argument, does not require the &ldquo;sub&rdquo; keyword or a subsequent comma.</p></blockquote>

<p>So if I try to pass <code>builder()</code> a scalar or an array or anything thats not an
anonymous subroutine, I will get a compile time error.  But if I pass it an
anonymous subroutine, the compiler will allow things to continue.</p>

<h1>Artful trick #2</h1>

<p>The next artful trick is that Plack::Builder implements the DSL keywords as
subs and then exports those subs.</p>

<pre><code>package Plack::Builder;
use strict;
use parent qw( Exporter );
our @EXPORT = qw( builder enable enable_if mount );
...
sub enable    {...}
sub enable_if {...}
sub mount     {...}
# etc
</code></pre>

<p>Actually thats 90% of the whole thing isn&rsquo;t it?  Now its starting to look
obvious.  But lets continue.</p>

<h1>Artful trick #3</h1>

<p>There is one more interesting idea here.  Notice that if I use <code>enable</code>,
<code>enable_if</code>, or <code>mount</code> outside of a <code>builder</code> block I will get an
error.  This works because the DSL keywords are subs which run code references.
By default those code references refer to code which croaks an error.  But when
<code>builder</code> runs, those references are temporarily replaced with real working
code.</p>

<p>Here&rsquo;s some simplified code to illustrate how it works.</p>

<pre><code>our $_enable = sub { Carp::croak(...) }; # &lt;&lt; default code reference

sub enable { $_enable-&gt;(@_) }

sub builder(&amp;) {
    my $block = shift;
    ...
    local $_enable = sub {...}; # &lt;&lt; temporarily assign real working code
    ...
    my $app = $block-&gt;();
    ...
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - PSGI Application Architecture]]></title>
    <link href="http://blog.kablamo.org/2014/04/11/read-plack-3/"/>
    <updated>2014-04-11T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/11/read-plack-3</id>
    <content type="html"><![CDATA[<ul>
<li><a href="/2014/04/08/read-plack-1">Part 1 &ndash; An Overview</a></li>
<li><a href="/2014/04/09/read-plack-2">Part 2 &ndash; plackup Architecture</a></li>
<li><a href="/2014/04/11/read-plack-3"><strong>Part 3 &ndash; PSGI Application Architecture</strong></a></li>
<li><a href="/2014/04/12/read-plack-4">Part 4 &ndash; Plack::Builder</a></li>
</ul>


<h1>PSGI Applications</h1>

<p>The <a href="https://metacpan.org/pod/distribution/PSGI/PSGI.pod">PSGI spec</a> defines
a PSGI application.</p>

<blockquote><p>A PSGI application is a Perl code reference. It takes exactly one argument,
the environment, and returns an array reference containing exactly three
values.</p></blockquote>

<p>The three values are a status, headers, and a body.  Here is an example:</p>

<pre><code>my $app = sub {
    my $env = shift;
    return [
        '200',
        [ 'Content-Type' =&gt; 'text/plain' ],
        [ "Hello World" ], # or IO::Handle-like object
    ];
};
</code></pre>

<h1>The PSGI environment hash</h1>

<p>The PSGI environment hash is a hashref with many keys.  But mostly it is the
data (headers, body, etc) from an <a href="HTTP::Request">HTTP::Request</a> which has been parsed and put into
a hash for convenient access.</p>

<h1>Middleware</h1>

<p>A middleware component takes a PSGI application and runs it, passing in the
PSGI environment hash.  But before it runs the app, it gets to modify the
environment if it wants to.  And after running the app, it can modify the
response if it wants to.</p>

<h1>Plack::Middleware</h1>

<p>Middleware is a wrapper around a PSGI app.  More than one middleware can be
wrapped around an app, creating a series of layers like an
<a href="http://blogs.perl.org/users/jakob/2012/09/28/middleware-onion.png/500px-MiddlewareOnion.svg.png">onion</a>.
What makes the middleware onion a somewhat unusual construct is the event
driven / callback nature of it.  Lets look at how its implemented.</p>

<p>All middleware inherits from Plack::Middleware which is an itsy bitsy (teeny
weeny) module.  The middleware onion is created with just 2 short subroutines
(notice the <code>call()</code> and <code>prepare_app()</code> subs are written by middleware authors):</p>

<pre><code>sub wrap {
    my($self, $app, @args) = @_;
    if (ref $self) {
        $self-&gt;{app} = $app;
    } else {
        $self = $self-&gt;new({ app =&gt; $app, @args });
    }
    return $self-&gt;to_app;
}

sub to_app {
    my $self = shift;
    $self-&gt;prepare_app;
    return sub { $self-&gt;call(@_) };
}
</code></pre>

<p>How do these subs work together?  The middleware onion is sometimes constructed as follows:</p>

<pre><code>my $app = MyWebApp-&gt;new-&gt;to_app;
$app = Plack::Middleware::A-&gt;wrap($app);
$app = Plack::Middleware::B-&gt;wrap($app);
$app = Plack::Middleware::C-&gt;wrap($app);
</code></pre>

<p>But it might be more clear to write it this way</p>

<pre><code>my $app0 = MyWebApp-&gt;new-&gt;to_app;           # $app0-&gt;($env) runs the web app
$app1 = Plack::Middleware::A-&gt;wrap($app0);  # $app1-&gt;($env) calls P::M::A-&gt;call() which calls $app0-&gt;($env)
$app2 = Plack::Middleware::B-&gt;wrap($app1);  # $app2-&gt;($env) calls P::M::B-&gt;call() which calls $app1-&gt;($env)
$app3 = Plack::Middleware::C-&gt;wrap($app2);  # $app3-&gt;($env) calls P::M::C-&gt;call() which calls $app2-&gt;($env)
                                            # When the server receives a request it calls $app3-&gt;($env)
</code></pre>

<p>So when an event occurs &mdash; for example the PSGI server sees a new request &mdash; it
passes the event to the app.  The app is a chain of callbacks which run each
other.  This is clearly an example of event driven programming.</p>

<h1>Plack::Component and Plack::App</h1>

<p>Plack::Middleware inherits from Plack::Component.  So the most common use of
Plack::Component is in middleware.</p>

<p>Plack::Component can also be used as a tool for creating PSGI applications.  It
has a light dusting of code, but mostly its an interface which is implemented
by modules in the Plack::App namespace.  For example Plack::App::File is a web
app which serves static files from a root directory, and Plack::App::URLMap is
a web app which maps multiple web apps to multiple urls.</p>

<p>But notice that I am not required to use Plack::Component to create a PSGI
application. A PSGI application is just a code reference.  The PSGI spec does
not say that a PSGI application is a reference to code that inherits from
Plack::Component.</p>

<p>The nice thing about using Plack::Component to build my app is that it
provides a common interface for all PSGI apps.  Whenever I see <code>$app</code>, I
can rely on that behavior.  This is clearly important for middleware.  And it
feels good from a design point of view.</p>

<p>But its not required and it adds some complexity.</p>
]]></content>
  </entry>
  
</feed>
