<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | KABLAMO]]></title>
  <link href="http://blog.kablamo.org/categories/perl/atom.xml" rel="self"/>
  <link href="http://blog.kablamo.org/"/>
  <updated>2014-05-12T09:02:57-05:00</updated>
  <id>http://blog.kablamo.org/</id>
  <author>
    <name><![CDATA[Eric Johnson]]></name>
    <email><![CDATA[kablamo@kablamo.org]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Test::Pretty - because TAP is unnattractive]]></title>
    <link href="http://blog.kablamo.org/2014/05/08/test-pretty/"/>
    <updated>2014-05-08T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/05/08/test-pretty</id>
    <content type="html"><![CDATA[<p><a href="https://metacpan.org/pod/Test::Pretty">Test::Pretty</a> makes my tests look like this:</p>

<p><img src="/images/for-posts/2014-05-08-test-pretty.png" width="500"></p>

<p>This is especially nice when I have subtests.</p>

<p><img src="/images/for-posts/2014-05-08-test-pretty-subtest2.png" width="200">
<img src="/images/for-posts/2014-05-08-test-pretty-subtest.png" width="200"></p>

<h1>How it works</h1>

<p>I can enable Test::Pretty like this</p>

<pre><code>prove -MTest::Pretty -vlr t
</code></pre>

<p>But typing extra characters is not fun.  Happily
<a href="http://tokuhirom.github.io/">@tokuhirom</a> also created a prove
<a href="https://metacpan.org/pod/App::Prove::Plugin::retty">plugin</a> (which is included
with the Test::Pretty module) which allows me to do this:</p>

<pre><code>prove -Pretty -vlr t
</code></pre>

<p>Shorter but still too much typing so I created a <code>~/.proverc</code> file which contains
the following lines:</p>

<pre><code>--lib
--verbose
--comments
--recurse
-Pretty
</code></pre>

<p>Now I can get pretty verbose recursive (etc) tests and I only need to type this</p>

<pre><code>prove t
</code></pre>

<p>You can view my <code>~/.proverc</code> and more goodies in my <a href="https://github.com/kablamo/dotfiles">dotfiles repo</a>).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why reading code is good for me]]></title>
    <link href="http://blog.kablamo.org/2014/04/23/reading-code/"/>
    <updated>2014-04-23T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/23/reading-code</id>
    <content type="html"><![CDATA[<ul>
<li><strong>So I can start kicking butt faster</strong> &ndash; When I start a new job or a new
contract. Or when I hack on a new feature.  Or every day of my life as a
programmer that involves legacy code.  Yeah pretty much all the time.</li>
<li><strong>So I can learn new tricks</strong> &ndash; Healthy languages evolve.  Idioms and slang
are tools for more efficiently expressing ideas.  I want to be on top of
that.  Also its best way to peak inside the mind of a talented developer and
steal and copy their skills.</li>
<li><strong>So I can work better with others</strong> &ndash; I understand their idioms because I have
seen them before.  And I can probably articulate why their idioms are awesome
or feeble.</li>
</ul>


<p>I must remember that attitude matters.  If I think of reading code as a painful
chore it will be.  But if I look for opportunity I find it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An experiment - Write code every day]]></title>
    <link href="http://blog.kablamo.org/2014/04/20/write-code-every-day/"/>
    <updated>2014-04-20T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/20/write-code-every-day</id>
    <content type="html"><![CDATA[<p>If you missed John Resig&rsquo;s recent post about <a href="http://ejohn.org/blog/write-code-every-day/">writing code everyday</a> I highly recommend it.</p>

<p>He is a busy guy with a full time job (at Khan Academy), a few open source side
projects (the author of jQuery), a wife, and a few hobbies.  How to sustainably
get stuff done on his open source side projects without his wife leaving him?
He decided to start writing (non work) code for 30 minutes every day.  This by
itself is not a revolutionary idea.  What blew my mind out of my nose and on to
the table are the benefits he encountered:</p>

<ul>
<li><strong>Minimum viable code</strong> &ndash; No time for more than that.</li>
<li><strong>Small but continuous progress</strong> &ndash; No anxiety about not getting stuff done.</li>
<li><strong>Free time on the weekends</strong> &ndash; Instead of working all
weekend to catch up from doing nothing during the week.</li>
<li><strong>Lowered cost of context switching</strong> &ndash; Compared to resuming work on a side project just on the weekends.</li>
<li><strong>Brain solves side project issues in the background</strong></li>
</ul>


<p>Wow, I need to do this too.  So this is
<a href="http://blog.kablamo.org/2014/03/24/experiments/">another</a>
<a href="http://blog.kablamo.org/2014/01/01/no-dessert-forever/">experiment</a> and here
are the rules.</p>

<ol>
<li> I will write code for a minimum of 30 minutes each day.</li>
<li> I must push working code every day.</li>
<li> I will write for a minimum of 10 minutes each day.</li>
<li> I must publish a blog post at least once a week.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codecube.io now supports Perl]]></title>
    <link href="http://blog.kablamo.org/2014/04/19/codecube/"/>
    <updated>2014-04-19T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/19/codecube</id>
    <content type="html"><![CDATA[<p><a href="http://codecube.io">Codecube.io</a> is a jsfiddle type service which runs Perl
code (and other languages) and shows the results in your browser.</p>

<p>The website is written in Go and runs your code inside a Docker container.  It
originally had support for C, Go, Python, and Ruby.  I was looking for an
excuse to play with Docker and Go so I submitted a pull request which added
support for Perl.</p>

<p>See also:</p>

<ul>
<li> The original Codecube <a href="http://hmarr.com/2013/oct/16/codecube-runnable-gists/">blog post</a> which is a good introduction to Docker.</li>
<li> The <a href="https://github.com/hmarr/codecube">Codecube github repo</a>.</li>
<li> My previous post on <a href="http://golang.org/">Go</a>.</li>
<li> My previous post on <a href="http://www.docker.io/">Docker</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading code - Plack::Builder]]></title>
    <link href="http://blog.kablamo.org/2014/04/12/read-plack-4/"/>
    <updated>2014-04-12T00:00:00-05:00</updated>
    <id>http://blog.kablamo.org/2014/04/12/read-plack-4</id>
    <content type="html"><![CDATA[<ul>
<li><a href="/2014/04/08/read-plack-1">Part 1 &ndash; An Overview</a></li>
<li><a href="/2014/04/09/read-plack-2">Part 2 &ndash; plackup Architecture</a></li>
<li><a href="/2014/04/11/read-plack-3">Part 3 &ndash; PSGI Application Architecture</a></li>
<li><a href="/2014/04/12/read-plack-4"><strong>Part 4 &ndash; Plack::Builder</strong></a></li>
</ul>


<p>Plack::Builder provides a domain specific language (DSL) for middleware
developers.  It looks like this:</p>

<pre><code>use Plack::Builder;

my $app1 = sub { ... };
my $app2 = sub { ... };

builder {
    enable "Deflater";
    enable "Session", store =&gt; "File";
    enable "Debug", panels =&gt; [ qw(DBITrace Memory Timer) ];

    mount "/narwhale" =&gt; $app1;
    mount "/unicorn"  =&gt; $app2;
};
</code></pre>

<p>How does it work?  With three artful tricks.</p>

<h1>Artful trick #1</h1>

<p>The first artful trick is the <code>builder</code> block.</p>

<pre><code>sub builder(&amp;) {
    my $block = shift;
    ...
}
</code></pre>

<p>The <code>&amp;</code> is a function prototype.  Perl offers some limited compile time checking
for parameters passed to subs.  Here is what <code>perldoc perlsub</code> says about <code>&amp;</code>:</p>

<blockquote><p>An &ldquo;&amp;&rdquo; requires an anonymous subroutine, which, if passed as the first
argument, does not require the &ldquo;sub&rdquo; keyword or a subsequent comma.</p></blockquote>

<p>So if I try to pass <code>builder()</code> a scalar or an array or anything thats not an
anonymous subroutine, I will get a compile time error.  But if I pass it an
anonymous subroutine, the compiler will allow things to continue.</p>

<h1>Artful trick #2</h1>

<p>The next artful trick is that Plack::Builder implements the DSL keywords as
subs and then exports those subs.</p>

<pre><code>package Plack::Builder;
use strict;
use parent qw( Exporter );
our @EXPORT = qw( builder enable enable_if mount );
...
sub enable    {...}
sub enable_if {...}
sub mount     {...}
# etc
</code></pre>

<p>Actually thats 90% of the whole thing isn&rsquo;t it?  Now its starting to look
obvious.  But lets continue.</p>

<h1>Artful trick #3</h1>

<p>There is one more interesting idea here.  Notice that if I use <code>enable</code>,
<code>enable_if</code>, or <code>mount</code> outside of a <code>builder</code> block I will get an
error.  This works because the DSL keywords are subs which run code references.
By default those code references refer to code which croaks an error.  But when
<code>builder</code> runs, those references are temporarily replaced with real working
code.</p>

<p>Here&rsquo;s some simplified code to illustrate how it works.</p>

<pre><code>our $_enable = sub { Carp::croak(...) }; # &lt;&lt; default code reference

sub enable { $_enable-&gt;(@_) }

sub builder(&amp;) {
    my $block = shift;
    ...
    local $_enable = sub {...}; # &lt;&lt; temporarily assign real working code
    ...
    my $app = $block-&gt;();
    ...
}
</code></pre>
]]></content>
  </entry>
  
</feed>
